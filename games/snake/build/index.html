<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: monospace;
    }
    #game-container { position: relative; }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #4ade80;
      font-size: 20px;
      z-index: 10;
    }
    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 40px;
      border-radius: 12px;
      text-align: center;
      display: none;
    }
    #game-over h2 { color: #ef4444; margin-bottom: 20px; font-size: 36px; }
    #game-over p { color: #fff; margin-bottom: 20px; font-size: 24px; }
    #game-over button {
      background: #4ade80;
      border: none;
      padding: 12px 32px;
      font-size: 18px;
      border-radius: 8px;
      cursor: pointer;
      font-family: monospace;
    }
    #game-over button:hover { background: #22c55e; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
</head>
<body>
  <div id="game-container">
    <div id="score">Score: 0</div>
    <div id="game-over">
      <h2>Game Over!</h2>
      <p>Final Score: <span id="final-score">0</span></p>
      <button onclick="location.reload()">Play Again</button>
    </div>
  </div>

  <script>
    const CONFIG = {
      tileSize: 32,
      gridWidth: 20,
      gridHeight: 15,
      speed: 120
    };

    class SnakeScene extends Phaser.Scene {
      constructor() {
        super('SnakeScene');
      }

      preload() {
        // Create graphics for snake segments
        const graphics = this.make.graphics({ x: 0, y: 0, add: false });
        graphics.fillStyle(0x4ade80);
        graphics.fillRoundedRect(0, 0, CONFIG.tileSize - 2, CONFIG.tileSize - 2, 4);
        graphics.generateTexture('snake-body', CONFIG.tileSize, CONFIG.tileSize);
        
        graphics.clear();
        graphics.fillStyle(0x22c55e);
        graphics.fillRoundedRect(0, 0, CONFIG.tileSize - 2, CONFIG.tileSize - 2, 4);
        graphics.generateTexture('snake-head', CONFIG.tileSize, CONFIG.tileSize);
        
        graphics.clear();
        graphics.fillStyle(0xef4444);
        graphics.fillCircle(CONFIG.tileSize/2, CONFIG.tileSize/2, CONFIG.tileSize/2 - 2);
        graphics.generateTexture('food', CONFIG.tileSize, CONFIG.tileSize);
      }

      create() {
        // Create background grid
        const bg = this.add.graphics();
        bg.fillStyle(0x16210f);
        bg.fillRect(0, 0, CONFIG.gridWidth * CONFIG.tileSize, CONFIG.gridHeight * CONFIG.tileSize);
        bg.lineStyle(1, 0x2d4a22);
        for (let x = 0; x <= CONFIG.gridWidth; x++) {
          bg.strokeLine(x * CONFIG.tileSize, 0, x * CONFIG.tileSize, CONFIG.gridHeight * CONFIG.tileSize);
        }
        for (let y = 0; y <= CONFIG.gridHeight; y++) {
          bg.strokeLine(0, y * CONFIG.tileSize, CONFIG.gridWidth * CONFIG.tileSize, y * CONFIG.tileSize);
        }

        // Initialize snake
        this.snake = [
          { x: 5, y: 7 },
          { x: 4, y: 7 },
          { x: 3, y: 7 },
          { x: 2, y: 7 }
        ];
        
        this.direction = { x: 1, y: 0 };
        this.nextDirection = { x: 1, y: 0 };
        this.score = 0;
        this.gameOver = false;

        // Spawn food
        this.spawnFood();

        // Render sprites
        this.snakeSprites = this.add.group();
        this.foodSprite = this.add.sprite(
          this.snake[0].x * CONFIG.tileSize,
          this.snake[0].y * CONFIG.tileSize,
          'snake-head'
        ).setScale(CONFIG.tileSize, CONFIG.tileSize);
        
        this.updateSnakeVisuals();

        // Update score display
        this.scoreText = document.getElementById('score');
        this.updateScore();

        // Input
        this.cursors = this.input.keyboard.createCursorKeys();

        // Timer
        this.moveTimer = 0;

        // Center camera
        this.cameras.main.setBounds(
          0, 0,
          CONFIG.gridWidth * CONFIG.tileSize,
          CONFIG.gridHeight * CONFIG.tileSize
        );
        this.cameras.main.setZoom(1);
      }

      spawnFood() {
        let valid = false;
        while (!valid) {
          this.food = {
            x: Phaser.Math.Between(0, CONFIG.gridWidth - 1),
            y: Phaser.Math.Between(0, CONFIG.gridHeight - 1)
          };
          valid = !this.snake.some(seg => seg.x === this.food.x && seg.y === this.food.y);
        }
        
        this.foodSprite = this.add.sprite(
          this.food.x * CONFIG.tileSize,
          this.food.y * CONFIG.tileSize,
          'food'
        ).setScale(CONFIG.tileSize, CONFIG.tileSize);
      }

      updateSnakeVisuals() {
        this.snakeSprites.clear(true);
        
        // Draw body
        for (let i = this.snake.length - 1; i > 0; i--) {
          const segment = this.snake[i];
          this.snakeSprites.create(
            segment.x * CONFIG.tileSize,
            segment.y * CONFIG.tileSize,
            'snake-body'
          ).setScale(CONFIG.tileSize, CONFIG.tileSize);
        }
        
        // Update head position
        const head = this.snake[0];
        this.foodSprite.x = head.x * CONFIG.tileSize;
        this.foodSprite.y = head.y * CONFIG.tileSize;
      }

      updateScore() {
        this.scoreText.textContent = `Score: ${this.score}`;
      }

      handleInput() {
        if (this.cursors.left.isDown && this.direction.x !== 1) {
          this.nextDirection = { x: -1, y: 0 };
        } else if (this.cursors.right.isDown && this.direction.x !== -1) {
          this.nextDirection = { x: 1, y: 0 };
        } else if (this.cursors.up.isDown && this.direction.y !== 1) {
          this.nextDirection = { x: 0, y: -1 };
        } else if (this.cursors.down.isDown && this.direction.y !== -1) {
          this.nextDirection = { x: 0, y: 1 };
        }
      }

      moveSnake() {
        this.direction = { ...this.nextDirection };
        
        const newHead = {
          x: this.snake[0].x + this.direction.x,
          y: this.snake[0].y + this.direction.y
        };

        // Check wall collision
        if (newHead.x < 0 || newHead.x >= CONFIG.gridWidth ||
            newHead.y < 0 || newHead.y >= CONFIG.gridHeight) {
          this.endGame();
          return;
        }

        // Check self collision
        if (this.snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
          this.endGame();
          return;
        }

        this.snake.unshift(newHead);

        // Check food collision
        if (newHead.x === this.food.x && newHead.y === this.food.y) {
          this.score += 10;
          this.updateScore();
          this.spawnFood();
        } else {
          this.snake.pop();
        }

        this.updateSnakeVisuals();
      }

      endGame() {
        this.gameOver = true;
        document.getElementById('final-score').textContent = this.score;
        document.getElementById('game-over').style.display = 'block';
      }

      update(time, delta) {
        if (this.gameOver) return;

        this.handleInput();
        this.moveTimer += delta;

        if (this.moveTimer >= CONFIG.speed) {
          this.moveTimer = 0;
          this.moveSnake();
        }
      }
    }

    const config = {
      type: Phaser.AUTO,
      width: CONFIG.gridWidth * CONFIG.tileSize,
      height: CONFIG.gridHeight * CONFIG.tileSize,
      parent: 'game-container',
      backgroundColor: '#1a1a2e',
      scene: [SnakeScene],
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    const game = new Phaser.Game(config);
  </script>
</body>
</html>